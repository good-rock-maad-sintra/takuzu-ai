\documentclass[12pt,a4paper]{article}
\usepackage[legalpaper, portrait, margin=2cm]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{pdflscape}
\usepackage{svg}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{minted}

\graphicspath{ {./} }
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdftitle={Relatório Projeto IA - 2021/2022},
  pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupo \textbf{5}}
\lhead{Relatório Projeto IA (Takuzu) 2021/2022 LEIC-A}
\cfoot{Diogo Gaspar (99207) e João Rocha (99256)}

\renewcommand{\footrulewidth}{0.2pt}

\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$\diamond$}
\newcommand{\op}{\text}

\newlist{constraintsList}{itemize}{4}
\setlist[constraintsList]{itemsep=1pt, topsep=1pt, label=\protect\mpbullet}

\begin{document}
  \begin{titlepage}
    \begin{center}
      \vspace*{5cm}

      \Huge
      \textbf{Projeto IA - Takuzu}

      \vspace{0.5cm}

      \LARGE
      Diogo Gaspar (99207), João Rocha (99256)

      \vspace{0.5cm}
      \Large
      Grupo 005 LEIC-A

      \vfill
    \end{center}
  \end{titlepage}

  \section*{Descrição do Problema e da Solução}

  Foi proposta a elaboração de um programa, em \texttt{Python}, que resolvesse, de forma eficiente o \textit{puzzle} binário \textit{takuzu}. \\

  Este \textit{puzzle} pede-nos para encontrar um tabuleiro, totalmente preenchido com 0's e 1's, partindo de uma configuração inicial, que satisfaça as seguintes restrições:
  \begin{itemize}
    \item Não podem haver 3 símbolos (0 ou 1) iguais consecutivos;
    \item A diferença entre o número de 1's e 0's numa dada linha ou coluna deve ser no máximo 1 (isto é, deve ser 0 em tabuleiros de tamanho par e 1 nos de tamanho ímpar);
    \item Todas as linhas devem ser diferentes entre si;
    \item Todas as colunas devem ser diferentes entre si.
  \end{itemize}

  No contexto da matéria de Inteligência Artificial, isto consiste em encontrar um estado \textbf{completo} e \textbf{consistente}, em que:
  \begin{itemize}
    \item Um estado é completo se não tiver células vazias;
    \item Um estado é consistente se satisfizer as 4 regras acima.
  \end{itemize}

  Chegar a um estado completo é bastante fácil, basta preencher todas as células do tabuleiro.
  Para garantir que atingimos um estado completo \textbf{e} consistente, basta então garantir que nunca fazemos uma jogada que nos leve a um estado inconsistente.

  Chamamos uma jogada de \textbf{impossível} se a execução desta levar a um estado inconsistente (o estado quebra alguma das regras supramencionadas).
  Destas regras, a única cuja verificação merece alguma explicação é a da identificação entre linhas/colunas.
  Para garantir que isto nunca acontece, guardamos a qualquer momento (na classe \texttt{Board}) dois \textit{sets}, cada uma guardando \textit{strings} binárias que representam, respetivamente, as linhas e colunas que já estão totalmente preenchidas no tabuleiro.
  Esta solução com \textit{strings} binárias permite aumentar consideravelmente a eficiência da verificação de igualdade entre linhas/colunas. 

  As jogadas podem ainda ser \textbf{possíveis} (corresponde apenas a não ser impossível) ou \textbf{obrigatórias} (se forem possíveis e o seu conjugado não for).
  Aqui, o conjugado de uma jogada corresponde à jogada que atua sobre a mesma célula, mas com o valor \textbf{conjugado} (isto é, se uma jogada coloca 0 na posição (1,3), a sua conjugada coloca 1 nessa mesma posição).

  Em cada estado, verificamos sempre se há alguma célula vazia em que ambas as jogadas sejam impossíveis.
  Neste caso, qualquer jogada nessa célula levaria a um estado em que o tabuleiro é inconsistente e não vale a pena prosseguir neste ramo da árvore de procura.

  Sempre que haja ações obrigatórias por realizar, num dado estado, realizamo-las. 
  Isto é apenas lógico, visto que, por definição de obrigatoriedade, vamos ter de as executar para chegar a qualquer tabuleiro solução.
  Assim, antecipando a sua execução, reduzimos o número de nós da nossa árvore de procura.

  Sempre que tal não é possível, escolhemos um par de ações possíveis para qualquer célula vazia do tabuleiro (note-se que uma vez que não há jogadas obrigatórias - células em que apenas uma jogada é possível - nem células em que não seja possível jogar, é necessariamente verdade que em qualquer célula vazia podemos colocar tanto um 0 como um 1).

  Esta decisão de devolver sempre no máximo duas ações traduz-se em que o \textit{branching factor} da nossa árvore é 2.
  Como vamos ver na análise experimental, isto é fundamental para a execução em tempo eficiente da nossa solução.

  Como a nossa procura é feita de forma a nunca alcançar estados inconsistentes, basta que o nosso \texttt{goal\_test} verifique se está num estado completo - um estado sem células vazias (nesse caso será uma solução).

  % TODO: enquadrar a nossa solução no contexto de CSP's

  \section*{Análise Experimental}

  % Assinalar que o branching factor tem bastante relevância na diferença entre
  % procuras.

  % hyperfine em cada procura com e sem branching factor a 2
  
\end{document}
